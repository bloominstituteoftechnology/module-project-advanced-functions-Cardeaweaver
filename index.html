<!DOCTYPE html>
<html lang="en">

<head>
  <title>Advanced Functions</title>
</head>

<body>
  <h1>Advanced Functions</h1>
  <p>Please load this file in VSCode and Chrome, and open the Console in Chrome Dev Tools.</p>
  <p>Work through the challenges found inside the script tag in this document,
    until the Console reports all tests passing.</p>

  <script>
    // In CHALLENGES 1-8 you will flesh out some functions.

    // To do this, translate each üß† set of instructions into a working function.
    // ‚ùó Functions are already scaffolded as arrow functions.
    // ‚ùó Watch the Guided Project to learn proper debugging technique.

    // üëâ CHALLENGE 1
    // üß† The function processSingleLearner takes a learner object as its argument, and returns it after some modifications.
    // üß† If the learner has a "lovesJS" property set to 0, we need to set it to false.
    // üß† If the learner has a "lovesJS" property set to 1, we need to set it to true.
    // ü§î The reason is that in some databases, Booleans true and false are actually stored as 1 and 0 respectively.
    // ü§î But real Booleans are easier to work with, and that is why we might need a function like this!
    // üß† Examples of usage:
    // processSingleLearner({ name: "Elisabeth", lovesJS: 1 }) // should return { name: "Elisabeth", lovesJS: true }
    // processSingleLearner({ name: "Pete", age: 23, lovesJS: 0 }) // should return { name: "Pete", age: 23, lovesJS: false }
    const processSingleLearner = (learner) => {
 // Check if the learner object has a 'lovesJS' property
 if ('lovesJS' in learner) {
        // If the value of 'lovesJS' is 0, set it to false
        if (learner.lovesJS === 0) {
            learner.lovesJS = false;
        }
        // If the value of 'lovesJS' is 1, set it to true
        else if (learner.lovesJS === 1) {
            learner.lovesJS = true;
        }
        // If the value of 'lovesJS' is neither 0 nor 1, do nothing
    }
    // Return the modified learner object
    return learner;
}
// Examples of usage:
console.log(processSingleLearner({ name: "Elisabeth", lovesJS: 1 }));
// Output: { name: "Elisabeth", lovesJS: true }

console.log(processSingleLearner({ name: "Pete", age: 23, lovesJS: 0 }));
// Output: { name: "Pete", age: 23, lovesJS: false }

    

    // üëâ CHALLENGE 2
    // üß† The function processLearnerLoop takes an array of learner objects as its argument, and returns it after some modifications.
    // üß† For each learner, if the learner has a "lovesJS" property set to 0, we need to set it to false.
    // üß† For each learner, if the learner has a "lovesJS" property set to 1, we need to set it to true.
    // üß† Examples of usage:
    // processSingleLearner([{ name: "Elisabeth", lovesJS: 1 },{ name: "Pete", age: 23, lovesJS: 0 }])
    //   should return [{ name: "Elisabeth", lovesJS: true },{ name: "Pete", age: 23, lovesJS: false }]
    // ‚ùó Notes:
    // üß† There are many approaches to this problem: using a loop, using forEach, using map...
    // üß† Solve this challenge using a for/in loop or a for loop.
    const processLearnersLoop = (learners) => {
// Iterate over each learner object in the array
for (let i = 0; i < learners.length; i++) {
        // Check if the current learner object has a 'lovesJS' property
        if ('lovesJS' in learners[i]) {
            // If the value of 'lovesJS' is 0, set it to false
            if (learners[i].lovesJS === 0) {
                learners[i].lovesJS = false;
            }
            // If the value of 'lovesJS' is 1, set it to true
            else if (learners[i].lovesJS === 1) {
                learners[i].lovesJS = true;
            }
            // If the value of 'lovesJS' is neither 0 nor 1, do nothing
        }
    }
    // Return the modified array of learner objects
    return learners;
}

    // üëâ CHALLENGE 3
    // üß† The function processLearnerForEach takes an array of learner objects as its argument, and returns it after some modifications.
    // üß† It is an alternate implementation of the function processLearnersLoop above.
    // ‚ùó Notes:
    // üß† Solve this challenge using the forEach method of the learners array.
    // üß† Use arrow functions whenever possible.

       function processLearnerForEach(learner) {
     // Iterate over each learner object in the array using forEach
     learner.forEach((learner) => {
        // Check if the current learner object has a 'lovesJS' property
        if ('lovesJS' in learner) {
            // If the value of 'lovesJS' is 0, set it to false
            if (learner.lovesJS === 0) {
                learner.lovesJS = false;
            }
            // If the value of 'lovesJS' is 1, set it to true
            else if (learner.lovesJS === 1) {
                learner.lovesJS = true;
            }
            // If the value of 'lovesJS' is neither 0 nor 1, do nothing
        }
    });
    // Return the modified array of learner objects
    return learner;}
        //     for (let learner= 0; learner < learner.length; i++) 
  //  learner.forEach(learner =>  {
  //   learner.isEnrolled = true;
  //   learner.completedLessons;
  // });

//   return learner
// }

    // üëâ CHALLENGE 4
    // üß† The function processLearnerMap takes an array of learner objects as its argument, and returns a new array.
    // üß† It is an alternate implementation of the function processLearnersLoop above.
    // ‚ùó Notes:
    // üß† Solve this challenge using the map method of the learners array.
    // üß† Use arrow functions.
    function processLearnerMap(learners) {
      
    // Use the map method to iterate over the learners array
    return learners.map(learner => {
        // Check if the current learner object has a 'lovesJS' property
        if ('lovesJS' in learner) {
            // If the value of 'lovesJS' is 0, set it to false
            if (learner.lovesJS === 0) {
                learner.lovesJS = false;
            }
            // If the value of 'lovesJS' is 1, set it to true
            else if (learner.lovesJS === 1) {
                learner.lovesJS = true;
            }
            // If the value of 'lovesJS' is neither 0 nor 1, keep it unchanged
        }
        // Return the modified learner object
        return learner;
    });
}

    // üëâ CHALLENGE 5
    // üß† The function getJavaScriptLoversForEach takes an array of learner objects and returns an array or a string.
    // üß† The returned array must contain only the learners who love JavaScript.
    // üß† However, if nobody loves JavaScript the function returns the string "no JS lovers here!".
    // üß† Another complication is that the lovesJS prop on the learner could be a Boolean (false/true) or a number (0/1).
    // ‚ùó Notes:
    // üß† Solve this challenge using the forEach method of the learners array.
    // üß† You will need to declare a result array into which you push learners from inside your forEach loop.
    const getJavaScriptLoversForEach = (learners) => {
      const jsLovers = []; // Create an empty array to store JavaScript lovers

learners.forEach(learner => {
  const lovesJS = learner.lovesJS !== undefined ? learner.lovesJS : false; // Handle undefined lovesJS prop
  if (lovesJS === true || lovesJS === 1) { // Check for true or 1 (numeric value)
    jsLovers.push(learner);
  }
});

return jsLovers.length > 0 ? jsLovers : "no JS lovers here!";
}


    

    // üëâ CHALLENGE 6
    // üß† The function getJavaScriptLoversFilter takes an array of learner objects and returns an array or a string.
    // üß† It should work exactly the same as the getJavaScriptLoversForEach function above.
    // ‚ùó Notes:
    // üß† Solve this challenge using the filter method of the learners array.
    function getJavaScriptLoversFilter(learners) {
  const jsLovers = learners.filter(learner => {
    const lovesJS = learner.lovesJS !== undefined ? learner.lovesJS : false;
    return lovesJS === true || lovesJS === 1;
  });

  return jsLovers.length > 0 ? jsLovers : "no JS lovers here!";
}

    // üëâ CHALLENGE 7
    // üß† The function sumOddInts takes an array of integers as its argument and returns an array with two elements.
    // üß† The first element is a number which is the sum of the odd integers in the original array.
    // üß† The second element is an array containing only the odd numbers from the original array, in the same order.
    // üß† Examples of usage:
    // sumOddInts([0, 1, 2, 3, 4, 5]) // should return [9, [1, 3, 5]]
    // sumOddInts([2, 5, 1, 4, 0]) // should return [6, [5, 1]]
    // sumOddInts([2, 6]) // should return [0, []]
    // sumOddInts([]) // should return [0, []]
    // ‚ùó Notes:
    // üß† This could be solved by using filter to make an array of odd integers, and then using forEach to add them up.
    // üß† Or you could opt for solving everything with a single forEach which is the recommended approach (saves a loop).
  function sumOddInts(numbers) {
  let sum = 0;
  const oddNumbers = [];

  numbers.forEach(number => {
    if (number % 2 !== 0) {
      sum += number;
      oddNumbers.push(number);
    }
  });

  return [sum, oddNumbers];
}
    // üëâ CHALLENGE 8
    // üß† The function checkInts takes any number of arguments, but each argument is an integer.
    // üß† The return value is a new array of strings, its length equal to the number of arguments passed.
    // üß† Each string is "even" if the integer was even, or "odd" if it was odd.
    // üß† If no arguments are passed however, return the string "pass some arguments, yo!".
    // üß† Examples of usage:
    // checkInts(0, 1, 2, 3, 4, 5) // should return ["even", "odd","even", "odd","even", "odd"]
    // checkInts(2, 5, 1, 4, 0) // should return ["even", "odd", "odd", "even", "even"]
    // checkInts(2, 6) // should return ["even", "even"]
    // ‚ùó Notes:
    // üß† Solve this problem using rest parameters and map.
    function checkInts(...numbers) {
  if (numbers.length === 0) {
    return "pass some arguments, yo!";
  }

  return numbers.map(number => (number % 2 === 0 ? "even" : "odd"));
}

    // üß™ TESTS, do not work below this line
    // üß™ TESTS, do not work below this line
    // üß™ TESTS, do not work below this line
    runTests('CHALLENGE 1 - processSingleLearner', processSingleLearner, [
      [[{ lovesJS: 1 }], { lovesJS: true }],
      [[{ lovesJS: 0 }], { lovesJS: false }],
      [[{ name: "Elisabeth", lovesJS: 1 }], { name: "Elisabeth", lovesJS: true }],
      [[{ name: "Pete", age: 23, lovesJS: 0 }], { name: "Pete", age: 23, lovesJS: false }],
    ])
    const processLearnersTest = [
      [[[{ name: "Elisabeth", lovesJS: 1 }, { name: "Pete", age: 23, lovesJS: 0 }]], [{ name: "Elisabeth", lovesJS: true }, { name: "Pete", age: 23, lovesJS: false }]],
      [[[{ lovesJS: 1 }, { lovesJS: 0 }, { lovesJS: 1 }, { lovesJS: 0 }]], [{ lovesJS: true }, { lovesJS: false }, { lovesJS: true }, { lovesJS: false }]],
    ]
    runTests('CHALLENGE 2 - processLearnersLoop', processLearnersLoop, processLearnersTest)
    runTests('CHALLENGE 3 - processLearnerForEach', processLearnerForEach, processLearnersTest)
    runTests('CHALLENGE 4 - processLearnerMap', processLearnerMap, processLearnersTest)
    const getJavaScriptLoversTest = [
      [[[{ name: "Elisabeth", lovesJS: 1 }, { name: "Pete", age: 23, lovesJS: 0 }]], [{ name: "Elisabeth", lovesJS: 1 }]],
      [[[{ name: "Elisabeth", lovesJS: false }, { name: "Pete", age: 23, lovesJS: true }]], [{ name: "Pete", age: 23, lovesJS: true }]],
      [[[{ lovesJS: 1 }, { lovesJS: 0 }, { lovesJS: true }, { lovesJS: false }]], [{ lovesJS: 1 }, { lovesJS: true }]],
      [[[{ lovesJS: false }, { lovesJS: 0 }, { lovesJS: false }]], "no JS lovers here!"],
    ]
    runTests('CHALLENGE 5 - getJavaScriptLoversForEach', getJavaScriptLoversForEach, getJavaScriptLoversTest)
    runTests('CHALLENGE 6 - getJavaScriptLoversFilter', getJavaScriptLoversFilter, getJavaScriptLoversTest)
    runTests('CHALLENGE 7 - sumOddInts', sumOddInts, [
      [[[0, 1, 2, 3, 4, 5]], [9, [1, 3, 5]]],
      [[[2, 5, 1, 4, 0]], [6, [5, 1]]],
      [[[2, 6]], [0, []]],
      [[[]], [0, []]],
    ])
    runTests('CHALLENGE 8 - checkInts', checkInts, [
      [[0, 1, 2, 3, 4, 5], ["even", "odd", "even", "odd", "even", "odd"]],
      [[2, 5, 1, 4, 0], ["even", "odd", "odd", "even", "even"]],
      [[2, 6], ["even", "even"]],
      [[3, 5], ["odd", "odd"]],
      [[], "pass some arguments, yo!"],
    ])
    function runTests(testName, func, tests) {
      let results = []
      tests.forEach(test => {
        const argsList = test[0]
        const expected = JSON.stringify(test[1])
        const actual = JSON.stringify(func.apply(null, JSON.parse(JSON.stringify(argsList))))
        results.push([argsList, expected, actual])
      })
      console.log('\n' + testName)
      if (results.every(result => result[1] === result[2])) console.log('\t‚úÖ All tests pass')
      else results.forEach((result, idx) => {
        if (result[1] === result[2]) console.log(`\t‚úÖ Test ${idx + 1} passes`)
        else console.log(`\t‚ùå Test ${idx + 1} fails: ${func.name}(${result[0]
          .map(JSON.stringify)}) should return ${result[1]} but returns ${result[2]}`)
      })
    }
  </script>
</body>

</html>
